var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Ignite","category":"page"},{"location":"#Ignite.jl","page":"Home","title":"Ignite.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Ignite.jl.","category":"page"},{"location":"#docstrings","page":"Home","title":"Docstrings","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Ignite]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Ignite]","category":"page"},{"location":"#Ignite.Ignite","page":"Home","title":"Ignite.Ignite","text":"Ignite.jl\n\n(Image: Dev) (Image: Build Status) (Image: Coverage)\n\nWelcome to Ignite.jl, a Julia port of the Python library ignite for simplifying neural network training and validation loops using events and handlers.\n\nIgnite.jl provides a simple yet flexible engine and event system, allowing for the easy composition of training pipelines with various events such as artifact saving, metric logging, and model validation. Event-based training abstracts away the training loop, replacing it with 1) a training engine which executes a single training step, 2) a data loader for the engine to iterate over, and 3) events and corresponding handlers which are attached to the engine, configured to fire at specific points during training.\n\nEvent handlers much more flexibile compared to other approaches like callbacks: they can be any callable, multiple handlers can be attached to a single event, multiple events can trigger the same handler, and custom events can be defined to fire at user-specified points during training. This makes adding functionality to your training pipeline easy, minimizing the need to modify existing code.\n\nQuick Start\n\nThe example below demonstrates how to use Ignite.jl to train a simple neural network while keeping track of evaluation metrics and displaying them every 5 epochs. Key features to note:\n\nThe training step is factored out of the training loop: the train_step function takes a batch of training data and computes the loss, gradients, and updates the model parameters.\nEvents are flexibly added to the training and evaluation engines to customize training: the evaluator logs metrics, and the trainer runs the evaluator every 5 epochs.\nData loaders can be any iterable collection. Here we use a DataLoader from MLUtils.jl\n\nusing Ignite\nusing Flux, Zygote, Optimisers, MLUtils # for training a neural network\nusing OnlineStats: Mean, fit! # for tracking evaluation metrics\n\n# Build simple neural network and initialize Adam optimizer\nmodel = Chain(Dense(1 => 32, tanh), Dense(32 => 1))\noptim = Optimisers.setup(Optimisers.Adam(1f-3), model)\n\n# Creat mock data and data loaders\nf(x) = 2x-x^3\nxtrain, xtest = randn(1, 10_000), randn(1, 100)\nytrain, ytest = f.(xtrain), f.(xtest)\ntrain_data_loader = DataLoader((; x = xtrain, y = ytrain); batchsize = 64, shuffle = true, partial = false)\neval_data_loader = DataLoader((; x = xtest, y = ytest); batchsize = 10, shuffle = false)\n\n# Create training engine:\n#   - `engine` is a reference to the parent `trainer` engine, created below\n#   - `batch` is a batch of training data, retrieved by iterating `train_data_loader`\n#   - (optional) return value is stored in `trainer.state.output`\nfunction train_step(engine, batch)\n    x, y = batch\n    l, gs = Zygote.withgradient(m -> sum(abs2, m(x) .- y), model)\n    global optim, model = Optimisers.update!(optim, model, gs[1])\n    return Dict(\"loss\" => l)\nend\ntrainer = Engine(train_step)\n\n# Create evaluation engine using `do` syntax:\nevaluator = Engine() do engine, batch\n    x, y = batch\n    ypred = model(x) # evaluate model on a single batch of validation data\n    return Dict(\"ytrue\" => y, \"ypred\" => ypred) # result is stored in `evaluator.state.output`\nend\n\n# Add events to the evaluation engine to track metrics:\n#   - when `evaluator` starts, initialize the running mean\n#   - after each iteration, compute eval metrics from predictions and update the running average\nadd_event_handler!(evaluator, STARTED()) do engine\n    engine.state.metrics = Dict(\"abs_err\" => Mean()) # new fields can be dynamically added to `engine.state`\nend\nadd_event_handler!(evaluator, ITERATION_COMPLETED()) do engine\n    o = engine.state.output\n    m = engine.state.metrics[\"abs_err\"]\n    fit!(m, abs.(o[\"ytrue\"] .- o[\"ypred\"]) |> vec)\nend\n\n# Add an event to the training engine to run `evaluator` every 5 epochs:\nadd_event_handler!(trainer, EPOCH_COMPLETED(every = 5)) do engine\n    Ignite.run!(evaluator, eval_data_loader)\n    @info \"Evaluation metrics: abs_err = $(evaluator.state.metrics[\"abs_err\"])\"\nend\n\n# Start the training\nIgnite.run!(trainer, train_data_loader; max_epochs = 25, epoch_length = 1_000)\n\nPeriodically save model\n\nEasily add custom functionality to your training process without modifying existing code by incorporating new events. For example, saving the current model and optimizer state to disk every 10 epochs using BSON.jl:\n\nusing BSON\n\n# Save model and optimizer state every 10 epochs\nadd_event_handler!(trainer, EPOCH_COMPLETED(every = 10)) do engine\n    @save \"model_and_optim.bson\" model optim\n    @info \"Saved model and optimizer state to disk\"\nend\n\nTrigger multiple functions per event\n\nMultiple event handlers can be added to the same event:\n\nadd_event_handler!(trainer, COMPLETED()) do engine\n    @info \"Training is ended\"\nend\nadd_event_handler!(engine -> display(engine.state.times), trainer, COMPLETED())\n\nAttach the same handler to multiple events\n\nThe boolean operators | and & can be used to combine events:\n\nadd_event_handler!(trainer, COMPLETED() | EPOCH_COMPLETED(every = 10)) do engine\n    # Runs at the end of every 10th epoch, or when training is completed\nend\n\nthrottled_event = EPOCH_COMPLETED(; every = 3) & EPOCH_COMPLETED(; event_filter = throttle_filter(30.0))\nadd_event_handler!(trainer, throttled_event) do engine\n    # Runs at the end of every 3rd epoch if at least 30s has passed since the last firing\nend\n\nDefine custom events\n\nCustom events can be created to track different stages in the training process.\n\nFor example, suppose we want to define events that fire at the start and finish of the backward pass and the optimizer step. All we need to do is define new event types that subtype AbstractPrimitiveEvent, and then fire them at appropriate points in the train_step process function using fire_event!:\n\nstruct BACKWARD_STARTED <: AbstractPrimitiveEvent end\nstruct BACKWARD_COMPLETED <: AbstractPrimitiveEvent end\nstruct OPTIM_STEP_STARTED <: AbstractPrimitiveEvent end\nstruct OPTIM_STEP_COMPLETED <: AbstractPrimitiveEvent end\n\nfunction train_step(engine, batch)\n    x, y = batch\n\n    # Compute the gradients of the loss with respect to the model\n    fire_event!(engine, BACKWARD_STARTED())\n    l, gs = Zygote.withgradient(m -> sum(abs2, m(x) .- y), model)\n    fire_event!(engine, BACKWARD_COMPLETED())\n\n    # Update the model's parameters\n    fire_event!(engine, OPTIM_STEP_STARTED())\n    global optim, model = Optimisers.update!(optim, model, gs[1])\n    fire_event!(engine, OPTIM_STEP_COMPLETED())\n\n    return Dict(\"loss\" => l)\nend\ntrainer = Engine(train_step)\n\nThen, add event handlers for these custom events as usual:\n\nadd_event_handler!(trainer, BACKWARD_COMPLETED(every = 10)) do engine\n    # This code runs after every 10th backward pass is completed\nend\n\n\n\n\n\n","category":"module"},{"location":"#Ignite.AbstractEvent","page":"Home","title":"Ignite.AbstractEvent","text":"Abstract event type for construction compound events.\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.AbstractPrimitiveErrorEvent","page":"Home","title":"Ignite.AbstractPrimitiveErrorEvent","text":"Basic events triggered by errors.\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.AbstractPrimitiveEvent","page":"Home","title":"Ignite.AbstractPrimitiveEvent","text":"Basic events fired by the engine.\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.AndEvent","page":"Home","title":"Ignite.AndEvent","text":"struct AndEvent{E1<:AbstractEvent, E2<:AbstractEvent} <: AbstractEvent\n\nAndEvent(event1::E1, event2::E2) wraps two events and triggers if and only if both wrapped events are triggered by the same primitive event firing.\n\nFields: \n\nevent1::AbstractEvent: The first wrapped event that will be considered for triggering.\nevent2::AbstractEvent: The second wrapped event that will be considered for triggering.\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.Engine","page":"Home","title":"Ignite.Engine","text":"mutable struct Engine{P}\n\nEngine(process_function::P; kwargs...) to be run; see Ignite.run!.\n\nFields: \n\nprocess_function::Any: A function that processes a single batch of data and returns an output.\ndataloader::Any: An iterable object that provides the data for the engine to process. Default: nothing\nstate::State: An object that holds the current state of the engine. Default: State()\nevent_handlers::Vector{EventHandler}: A list of event handlers that are called at specific points when the engine is running. Default: EventHandler[]\nlogger::Union{Nothing, Base.CoreLogging.AbstractLogger}: An optional logger; if nothing, then current_logger() will be used. Default: nothing\nshould_terminate::Bool: A flag that indicates whether the engine should stop running. Default: false\n_dataloader_iter::Any: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.EventHandler","page":"Home","title":"Ignite.EventHandler","text":"struct EventHandler{E<:AbstractEvent, H}\n\nEventHandler(event::E, handler!::H) wraps an event and fires the corresponding handler! when event is triggered.\n\nFields: \n\nevent::AbstractEvent: Event which triggers handler\nhandler!::Any: Event handler which executes when triggered by event\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.FilteredEvent","page":"Home","title":"Ignite.FilteredEvent","text":"struct FilteredEvent{E<:AbstractEvent, F} <: AbstractEvent\n\nFilteredEvent(event::E, filter::F = Returns(true)) wraps an event and a filter function.\n\nWhen a primitive event e is fired, if filter(engine, e) returns true then the filtered event will be fired too.\n\nFields: \n\nevent::AbstractEvent: The wrapped event that will be fired if the filter function returns true when applied to a primitive event.\nfilter::Any: The filter function filter(engine::Engine, e::AbstractPrimitiveEvent)::Bool returns true if the wrapped event should be fired. Default: Returns(true)\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.OrEvent","page":"Home","title":"Ignite.OrEvent","text":"struct OrEvent{E1<:AbstractEvent, E2<:AbstractEvent} <: AbstractEvent\n\nOrEvent(event1::E1, event2::E2) wraps two events and triggers if either of the wrapped events are triggered by a primitive event firing.\n\nFields: \n\nevent1::AbstractEvent: The first wrapped event that will be checked if it should be fired.\nevent2::AbstractEvent: The second wrapped event that will be checked if it should be fired.\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.State","page":"Home","title":"Ignite.State","text":"struct State\n\nCurrent state of the engine. Fields can be accessed and modified using getproperty and setproperty!.\n\nState is a light wrapper around a DefaultOrderedDict{Symbol, Any, Nothing} with the following keys:\n\n:iteration: the current iteration, beginning with 1.\n:epoch: the current epoch, beginning with 1.\n:dataloader: The data loader passed to the engine.\n:max_epochs: The number of epochs to run.\n:epoch_length: The number of batches processed per epoch.\n:batch: The current batch passed to process_function.\n:output: The output of process_function after a single iteration.\n:last_event: The last event fired.\n:counters: A DefaultOrderedDict{AbstractPrimitiveEvent, Int, Int}(0) with primitive event firing counters.\n:times: An OrderedDict{AbstractPrimitiveEvent, Float64}() with total and per-epoch times fetched on primitive event keys.\n\nFor example, engine.state.iteration can be used to access the current iteration.\n\n\n\n\n\n","category":"type"},{"location":"#Ignite.add_event_handler!-Tuple{Any, Engine, AbstractEvent}","page":"Home","title":"Ignite.add_event_handler!","text":"add_event_handler!(\n    handler,\n    engine::Engine,\n    event::AbstractEvent\n) -> Engine\n\n\nAdd event handler to engine which is fired when event is triggered.\n\n\n\n\n\n","category":"method"},{"location":"#Ignite.every_filter-Tuple{Union{Int64, AbstractVector{Int64}}}","page":"Home","title":"Ignite.every_filter","text":"every_filter(\n    every::Union{Int64, AbstractVector{Int64}}\n) -> Ignite.EveryFilter\n\n\nCreates a filter function for use in a FilteredEvent that returns true periodically depending on every:\n\nIf every = n::Int, the filter will trigger every nth firing of the event. \nIf every = Int[n₁, n₂, ...], the filter will trigger every n₁th firing, every n₂th firing, and so on.\n\n\n\n\n\n","category":"method"},{"location":"#Ignite.fire_event!-Tuple{Engine, EventHandler, AbstractPrimitiveEvent}","page":"Home","title":"Ignite.fire_event!","text":"fire_event!(\n    engine::Engine,\n    handler::EventHandler,\n    e::AbstractPrimitiveEvent\n) -> Engine\n\n\nExecute handler if it is triggered by the primitive event e.\n\n\n\n\n\n","category":"method"},{"location":"#Ignite.once_filter-Tuple{Union{Int64, AbstractVector{Int64}}}","page":"Home","title":"Ignite.once_filter","text":"once_filter(\n    once::Union{Int64, AbstractVector{Int64}}\n) -> Ignite.OnceFilter\n\n\nCreates a filter function for use in a FilteredEvent that returns true at specific points depending on once:\n\nIf once = n::Int, the filter will trigger only on the nth firing of the event. \nIf once = Int[n₁, n₂, ...], the filter will trigger only on the n₁th firing, the n₂th firing, and so on.\n\n\n\n\n\n","category":"method"},{"location":"#Ignite.run!","page":"Home","title":"Ignite.run!","text":"run!(engine::Engine) -> Engine\nrun!(\n    engine::Engine,\n    dataloader;\n    max_epochs,\n    epoch_length\n) -> Engine\n\n\nRun the engine. Data batches are retrieved by iterating dataloader. The data loader may be infinite; by default, it is wrapped in Iterators.cycle to restart if it empties.\n\nInputs:\n\nengine::Engine: An instance of the Engine struct containing the process_function to run each iteration.\ndataloader:  A data loader to iterate over. Defaults to engine.dataloader.\nmax_epochs::Int: the number of epochs to run. Defaults to 1.\nepoch_length::Int: the length of an epoch. If not given, will try to default to length(dataloader).\n\nConceptually, running the engine is roughly equivalent to the following:\n\nThe engine state is initialized.\nThe engine begins running for max_epochs epochs, or until the should_terminate flag is set to true.\nAt the start of each epoch, EPOCH_STARTED() event is fired and time is recorded.\nAn iteration loop is performed for epoch_length number of iterations, or until the should_terminate flag is set to true.\nAt the start of each iteration, ITERATION_STARTED() event is fired, and a batch of data is loaded.\nThe process_function is called on the loaded data batch.\nAt the end of each iteration, ITERATION_COMPLETED() event is fired.\nAt the end of each epoch, EPOCH_COMPLETED() event is fired.\nAt the end of all the epochs, COMPLETED() event is fired.\nFinally, TERMINATE() event is fired if should_terminate flag is set to true.\n\n\n\n\n\n","category":"function"},{"location":"#Ignite.throttle_filter-Tuple{Real}","page":"Home","title":"Ignite.throttle_filter","text":"throttle_filter(throttle::Real) -> Ignite.ThrottleFilter\n\n\nCreates a filter function for use in a FilteredEvent that returns true if at least throttle seconds has passed since it was last fired.\n\n\n\n\n\n","category":"method"},{"location":"#Ignite.@on-Tuple{Any, Any, Any}","page":"Home","title":"Ignite.@on","text":"@on engine event handler is syntax sugar for add_event_handler!(handler, engine, event).\n\n\n\n\n\n","category":"macro"}]
}
